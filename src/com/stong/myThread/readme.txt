Thread和Runable的区别
	如果一个类继承了Thread，则不适合资源共享，但如果实现了Runnable接口的话，则很容易实现资源共享
	实现Runable接口比继承Thread类所局所具有的优势总结：
	1）：适合多个相同的程序代码的线程去处理同一个资源
	2）：可以避免java中单继承的限制
	3）：增加程序的健壮性吗，代码可以被多个线程共享，代码和数据独立
	4）：线程池中只能放入实现Runnable和callable类线程，不能直接放入继承Thread类
	
	
线程状态转换：
	1.新建状态（new）：新创建了一个线程对象
	2.就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的start()，该线程位于可运行线程池中，变得可运行，等待获取CPU的使用权
	3.运行状态（Running）：就绪状态的线程获取到了CPU，执行程序代码
	4.阻塞状态（Blocked）：阻塞状态是线程因某种原因放弃CPU的使用权，暂时停止运行，知道线程进入就绪状态，才有机会转成运行状态，阻塞的情况分为三种：
		1）：等待阻塞：运行的线程执行wait方法，JVM会把该线程放入等待池中（wait会释放持有的锁）
		2）：同步阻塞：运行的线程在获取对象的同步锁时，若若该同步锁被其他线程占用，则JVM会把该线程放入锁池中。
		3）：其他阻塞：运行的线程执行sleep或join方法，或者发出了IO请求时，JVM会把该线程置为阻塞状态，当sleep()状态超时，join()等待线程终止或者超时，或者IO处理完毕时，线程重新转入就绪状态
			（sleep是不会释放所持有的锁的）
	5.死亡状态（Dead）:线程执行完了或者因异常退出了run方法，该线程结束声明周期
	
	
	
线程调度：
	1.调整线程优先级，Java线程有优先级，优先级高的线程获取较多的运行机会
	Thread类的setPriority()和getPriority()分别用来获取和设置线程的优先级，每个线程默认优先级都是Thread.NORM_PRIORITY
	线程的优先级有继承关系，比如A线程中创建了B线程，那么B将和A具有相同的优先级
	2.线程睡眠：Thread.sleep(long millis)方法，使线程转到阻塞状态。millis参数设定睡眠的时间，以毫秒为单位。当睡眠结束后，就转为就绪（Runnable）状态。sleep()平台移植性好。
	3.线程等待：Object类中的wait()方法，导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 唤醒方法。这个两个唤醒方法也是Object类中的方法，行为等价于调用 wait(0) 一样。
	4.线程让步：Thread.yield() 方法，暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。
	5.线程加入：join()方法，等待其他线程终止。在当前线程中调用另一个线程的join()方法，则当前线程转入阻塞状态，直到另一个进程运行结束，当前线程再由阻塞转为就绪状态。
	6.线程唤醒：Object类中的notify()方法，唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。选择是任意性的，并在对实现做出决定时发生。线程通过调用其中一个 wait 方法，在对象的监视器上等待。
	 直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程。被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争；例如，唤醒的线程在作为锁定此对象的下一个线程方面没有可靠的特权或劣势。类似的方法还有一个notifyAll()，
	 唤醒在此对象监视器上等待的所有线程。注意：Thread中suspend()和resume()两个方法在JDK1.5中已经废除，不再介绍。因为有死锁倾向。


常用函数：
	1.sleep(long millis): 在指定的毫秒数内让当前正在执行的线程休眠（暂停执行）
	2.join():指等待t线程终止。例如子线程调用join方法，则main函数主线程需要在子线程结束之后才能获取到线程
	3.yield():暂停当前正在执行的线程对象，并执行其他线程
	4.setPriority(): 更改线程的优先级
	5.interrupt():不要以为它是中断某个线程！它只是线线程发送一个中断信号，让线程在无限等待时（如死锁时）能抛出抛出，从而结束线程，但是如果你吃掉了这个异常，那么这个线程还是不会中断的！
	6.Object.wait() Obj.wait()，与Obj.notify()必须要与synchronized(Obj)一起使用，也就是wait,与notify是针对已经获取了Obj锁进行操作，从语法角度来说就是Obj.wait(),Obj.notify必须在
	synchronized(Obj){...}语句块内。从功能上来说wait就是说线程在获取对象锁后，主动释放对象锁，同时本线程休眠。直到有其它线程调用对象的notify()唤醒该线程，才能继续获取对象锁，并继续执行。相应的notify()
	就是对对象锁的唤醒操作。但有一点需要注意的是notify()调用后，并不是马上就释放对象锁的，而是在相应的synchronized(){}语句块执行结束，自动释放锁后，JVM会在wait()对象锁的线程中随机选取一线程，赋予其对象锁，
	唤醒线程，继续执行。这样就提供了在线程间同步、唤醒的操作。Thread.sleep()与Object.wait()二者都可以暂停当前线程，释放CPU控制权，主要的区别在于Object.wait()在释放CPU同时，释放了对象锁的控制。
	
	
synchronized:
	1.synchronized锁定的的是调用当前这个同步方法对象，但是这个对象所属的Class所产生的另一对象P2却可以任意调用这个被加了synchronized关键字的方法。
	2.如果一个类中定义了一个synchronized的static函数A，也定义了一个synchronized 的instance函数B，那么这个类的同一对象Obj在多线程中分别访问A和B两个方法时，
	不会构成同步，因为它们的锁都不一样。A方法的锁是Obj这个对象，而B的锁是Obj所属的那个Class
